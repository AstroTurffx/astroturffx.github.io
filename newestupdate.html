<!DOCTYPE html>
<html>
    <head>
        <title>AstroTurffx</title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
        <script src="parallax.min.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body, html {
                margin:0;
                height: 100%;
                font-family: Arial, Helvetica, sans-serif;
            }
            h1.title{
                font-size: 75px;
                text-align: center;
                color: white;
                font-weight: normal;
            }
            h3.learn{
                font-size: 40px;
                text-align: center;
                color: black;
                font-weight: normal;
            }
            .bg100 {
                min-height: 100%;
                width: 100%;
                height: 100%;
                display: table;
                text-align: center;
                background: transparent;
            }
            .bg50 {
                min-height: 50%;
                width: 100%;
                height: 50%;
                display: table;
                text-align: center;
                background: transparent;
            }
            .bg100 > h1.title {
                display: table-cell;
                vertical-align: middle;
            }
            .bg50 > h1.title {
                display: table-cell;
                vertical-align: middle;
            }
            .idk{
                font-size: 24px;
                text-align: center;
                margin: 0 auto;
                max-width: 50%;
            }
            .navbaritem {
                float: left;
            }
            .navbaritem a {
                display: block;
                color: white;
                text-align: center;
                padding: 14px 16px;
                text-decoration: none;
            }
            .navbaritem a:hover {
                background-color: #111;
            }
            .navbar{
                position: fixed;
                list-style-type: none;
                margin: 0;
                padding: 5px;
                overflow: hidden;
                background-color: #333333;
            }
            h3{
                font-size: 40px;
                text-align: center;
                font-weight: normal;
            }
            h4{
                font-size: 30px;
                text-align: center;
                font-weight: normal;
            }
            .imgcard{
                background-color: #aaaaaa;
                padding: 15px;
                margin: 15px;
            }
        </style>
    </head>
    <body>
        <ul class="navbar">
            <li class="navbaritem"><a href="newestupdate.html">1.16</a></li>
            <li class="navbaritem"><a href="servers.html">Servers</a></li>
        </ul>
        <div class="bg100" data-parallax="scroll" data-image-src="images/nether1.jpg"><h1 class="title">Minecraft 1.16<br>The nether Update</h1></div>
        <h3 class="learn">What got added in 1.16?</h3>
        <p class="idk">
            1.16, the first release of the Nether Update, is a major
            update to Java Edition and released on June 23, 2020.
            This update overhauls the Nether by adding four new biomes,
            four new mobs (the piglin, hoglin, zoglin, and strider),
            and a multitude of new blocks, including many variants of
            blackstone as well as the respawn anchor used to set the
            player's spawnpoint in the Nether. It also adds a new
            netherite tier of equipment, obtained through ancient
            debris found rarely throughout the Nether. 
        </p>
        <br>
        <div class="bg50" data-parallax="scroll" data-image-src="images/piglin1.jpg"><h1 class="title">Piglins</h1></div>
        <div style="float: right;">
            <div class="imgcard">
                <img src="images/piglin2.png" width="125" height="201">
                <h5>Piglin</h5>
            </div>
            <div class="imgcard">
                <img src="images/zombifiedpiglin.png" width="125" height="210">
                <h5>Zombified Piglin</h5>
            </div>
            <div class="imgcard">
                <img src="images/piglinbrute.png" width="125" height="210">
                <h5>Piglin Brute</h5>
            </div>
        </div>
        <div style="font-size: 24px; text-align: center; margin: 0 auto; max-width: 50%;">
            <h4>Normal Piglins</h4>
            <p>
                Piglins are neutral mobs found in the Nether. Unless
                wearing a piece of golden armor, players are attacked
                by them on sight. Players can barter using gold ingots
                to receive various items.
            </p>
            <h4>Zombified Piglins</h4>
            <p>
                When in the Overworld or the End, piglins transform into
                zombified piglins after 15 seconds, retaining their armor
                and held items. However, they cannot shoot a crossbow and
                only melee-fight the player with it. Upon transformation,
                the spawned zombified piglin has the Nausea effect for 10
                seconds; this is just a cosmetic effect. When piglins
                transform into zombified piglins, they drop anything except
                equipped arms and armor in their inventories and their
                inventories disappear.
            </p>
            <h4>Piglins Brute</h4>
            <p>
                When in the Overworld or the End, piglins transform into
                zombified piglins after 15 seconds, retaining their armor
                and held items. However, they cannot shoot a crossbow and
                only melee-fight the player with it. Upon transformation,
                the spawned zombified piglin has the Nausea effect for 10
                seconds; this is just a cosmetic effect. When piglins
                transform into zombified piglins, they drop anything except
                equipped arms and armor in their inventories and their
                inventories disappear.
            </p>
        </div>
        <br>
        <script>
            !function (t, i, e, s) {
                function o(i, e) {
                    var h = this;
                    "object" == typeof e && (delete e.refresh, delete e.render, t.extend(this, e)), this.$element = t(i), !this.imageSrc && this.$element.is("img") && (this.imageSrc = this.$element.attr("src")); var r = (this.position + "").toLowerCase().match(/\S+/g) || []; if (r.length < 1 && r.push("center"), 1 == r.length && r.push(r[0]), "top" != r[0] && "bottom" != r[0] && "left" != r[1] && "right" != r[1] || (r = [r[1], r[0]]), this.positionX !== s && (r[0] = this.positionX.toLowerCase()), this.positionY !== s && (r[1] = this.positionY.toLowerCase()), h.positionX = r[0], h.positionY = r[1], "left" != this.positionX && "right" != this.positionX && (isNaN(parseInt(this.positionX)) ? this.positionX = "center" : this.positionX = parseInt(this.positionX)), "top" != this.positionY && "bottom" != this.positionY && (isNaN(parseInt(this.positionY)) ? this.positionY = "center" : this.positionY = parseInt(this.positionY)), this.position = this.positionX + (isNaN(this.positionX) ? "" : "px") + " " + this.positionY + (isNaN(this.positionY) ? "" : "px"), navigator.userAgent.match(/(iPod|iPhone|iPad)/)) return this.imageSrc && this.iosFix && !this.$element.is("img") && this.$element.css({ backgroundImage: "url(" + this.imageSrc + ")", backgroundSize: "cover", backgroundPosition: this.position }), this; if (navigator.userAgent.match(/(Android)/)) return this.imageSrc && this.androidFix && !this.$element.is("img") && this.$element.css({ backgroundImage: "url(" + this.imageSrc + ")", backgroundSize: "cover", backgroundPosition: this.position }), this; this.$mirror = t("<div />").prependTo(this.mirrorContainer); var a = this.$element.find(">.parallax-slider"), n = !1; 0 == a.length ? this.$slider = t("<img />").prependTo(this.$mirror) : (this.$slider = a.prependTo(this.$mirror), n = !0), this.$mirror.addClass("parallax-mirror").css({ visibility: "hidden", zIndex: this.zIndex, position: "fixed", top: 0, left: 0, overflow: "hidden" }), this.$slider.addClass("parallax-slider").one("load", function () { h.naturalHeight && h.naturalWidth || (h.naturalHeight = this.naturalHeight || this.height || 1, h.naturalWidth = this.naturalWidth || this.width || 1), h.aspectRatio = h.naturalWidth / h.naturalHeight, o.isSetup || o.setup(), o.sliders.push(h), o.isFresh = !1, o.requestRender() }), n || (this.$slider[0].src = this.imageSrc), (this.naturalHeight && this.naturalWidth || this.$slider[0].complete || a.length > 0) && this.$slider.trigger("load")
                } !function () {
                    for (var t = 0, e = ["ms", "moz", "webkit", "o"], s = 0;
                        s < e.length && !i.requestAnimationFrame; ++s)i.requestAnimationFrame = i[e[s] + "RequestAnimationFrame"], i.cancelAnimationFrame = i[e[s] + "CancelAnimationFrame"] || i[e[s] + "CancelRequestAnimationFrame"];
                    i.requestAnimationFrame || (i.requestAnimationFrame = function (e) { var s = (new Date).getTime(), o = Math.max(0, 16 - (s - t)), h = i.setTimeout(function () { e(s + o) }, o); return t = s + o, h }), i.cancelAnimationFrame || (i.cancelAnimationFrame = function (t) { clearTimeout(t) })
                }(), t.extend(o.prototype, { speed: .2, bleed: 0, zIndex: -100, iosFix: !0, androidFix: !0, position: "center", overScrollFix: !1, mirrorContainer: "body", refresh: function () { this.boxWidth = this.$element.outerWidth(), this.boxHeight = this.$element.outerHeight() + 2 * this.bleed, this.boxOffsetTop = this.$element.offset().top - this.bleed, this.boxOffsetLeft = this.$element.offset().left, this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight; var t, i = o.winHeight, e = o.docHeight, s = Math.min(this.boxOffsetTop, e - i), h = Math.max(this.boxOffsetTop + this.boxHeight - i, 0), r = this.boxHeight + (s - h) * (1 - this.speed) | 0, a = (this.boxOffsetTop - s) * (1 - this.speed) | 0; r * this.aspectRatio >= this.boxWidth ? (this.imageWidth = r * this.aspectRatio | 0, this.imageHeight = r, this.offsetBaseTop = a, t = this.imageWidth - this.boxWidth, "left" == this.positionX ? this.offsetLeft = 0 : "right" == this.positionX ? this.offsetLeft = -t : isNaN(this.positionX) ? this.offsetLeft = -t / 2 | 0 : this.offsetLeft = Math.max(this.positionX, -t)) : (this.imageWidth = this.boxWidth, this.imageHeight = this.boxWidth / this.aspectRatio | 0, this.offsetLeft = 0, t = this.imageHeight - r, "top" == this.positionY ? this.offsetBaseTop = a : "bottom" == this.positionY ? this.offsetBaseTop = a - t : isNaN(this.positionY) ? this.offsetBaseTop = a - t / 2 | 0 : this.offsetBaseTop = a + Math.max(this.positionY, -t)) }, render: function () { var t = o.scrollTop, i = o.scrollLeft, e = this.overScrollFix ? o.overScroll : 0, s = t + o.winHeight; this.boxOffsetBottom > t && this.boxOffsetTop <= s ? (this.visibility = "visible", this.mirrorTop = this.boxOffsetTop - t, this.mirrorLeft = this.boxOffsetLeft - i, this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed)) : this.visibility = "hidden", this.$mirror.css({ transform: "translate3d(" + this.mirrorLeft + "px, " + (this.mirrorTop - e) + "px, 0px)", visibility: this.visibility, height: this.boxHeight, width: this.boxWidth }), this.$slider.css({ transform: "translate3d(" + this.offsetLeft + "px, " + this.offsetTop + "px, 0px)", position: "absolute", height: this.imageHeight, width: this.imageWidth, maxWidth: "none" }) } }), t.extend(o, { scrollTop: 0, scrollLeft: 0, winHeight: 0, winWidth: 0, docHeight: 1 << 30, docWidth: 1 << 30, sliders: [], isReady: !1, isFresh: !1, isBusy: !1, setup: function () { function s() { if (p == i.pageYOffset) return i.requestAnimationFrame(s), !1; p = i.pageYOffset, h.render(), i.requestAnimationFrame(s) } if (!this.isReady) { var h = this, r = t(e), a = t(i), n = function () { o.winHeight = a.height(), o.winWidth = a.width(), o.docHeight = r.height(), o.docWidth = r.width() }, l = function () { var t = a.scrollTop(), i = o.docHeight - o.winHeight, e = o.docWidth - o.winWidth; o.scrollTop = Math.max(0, Math.min(i, t)), o.scrollLeft = Math.max(0, Math.min(e, a.scrollLeft())), o.overScroll = Math.max(t - i, Math.min(t, 0)) }; a.on("resize.px.parallax load.px.parallax", function () { n(), h.refresh(), o.isFresh = !1, o.requestRender() }).on("scroll.px.parallax load.px.parallax", function () { l(), o.requestRender() }), n(), l(), this.isReady = !0; var p = -1; s() } }, configure: function (i) { "object" == typeof i && (delete i.refresh, delete i.render, t.extend(this.prototype, i)) }, refresh: function () { t.each(this.sliders, function () { this.refresh() }), this.isFresh = !0 }, render: function () { this.isFresh || this.refresh(), t.each(this.sliders, function () { this.render() }) }, requestRender: function () { var t = this; t.render(), t.isBusy = !1 }, destroy: function (e) { var s, h = t(e).data("px.parallax"); for (h.$mirror.remove(), s = 0; s < this.sliders.length; s += 1)this.sliders[s] == h && this.sliders.splice(s, 1); t(e).data("px.parallax", !1), 0 === this.sliders.length && (t(i).off("scroll.px.parallax resize.px.parallax load.px.parallax"), this.isReady = !1, o.isSetup = !1) } }); var h = t.fn.parallax; t.fn.parallax = function (s) { return this.each(function () { var h = t(this), r = "object" == typeof s && s; this == i || this == e || h.is("body") ? o.configure(r) : h.data("px.parallax") ? "object" == typeof s && t.extend(h.data("px.parallax"), r) : (r = t.extend({}, h.data(), r), h.data("px.parallax", new o(this, r))), "string" == typeof s && ("destroy" == s ? o.destroy(this) : o[s]()) }) }, t.fn.parallax.Constructor = o, t.fn.parallax.noConflict = function () { return t.fn.parallax = h, this }, t(function () { t('[data-parallax="scroll"]').parallax() })
            }(jQuery, window, document);
        </script>
    </body>
</html>
